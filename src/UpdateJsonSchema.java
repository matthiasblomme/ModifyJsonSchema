import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class UpdateJsonSchema {
    /**
     * Definition of json draft-04 schema
     */
     static final String defaultSchema = "{\n\t\"$schema\":\"http://json-schema.org/draft-04/schema#\",";

    /**
     * Variable that contains the allOf definition to replace the anyOf generated by jsonix
     */
    static String anyOf;

    /**
     * Pattern that matches the first entry {
     */
    static final String startPattern = "^\\{";

    static final String titlePattern = "(.*:\")([A-Z])(.*?\".*)";
    static final String fieldPattern = "(\\s+\")([A-Z])(.*?:\\{\\s*)";
    static final String refPattern1 = "(.*#/definitions/)([A-Z])(.*)";
    static final String refPattern2 = "(.*#/definitions/.*\\.)([A-Z])(.*)";

    /**
     * Pattern that matches the jsonix schema definitions
     */
    static final String jsonixSchemaPattern = "(\\s+)\"\\$ref\":\"http://www.jsonix.org/jsonschemas/w3c/2001/XMLSchema.jsonschema#/definitions/(.*?)\"";
    /**
     * Main method for the java class. It requires 3 input parameters
     *  - input file of the jsonix schema definition
     *  - Name of the json schema object/file
     *  The generated output file is ./generated/[SchemaObject].schema.json
     *  You need to run the jsonix schema generation first
     *  java -jar jsonix-schema-compiler-full-2.3.9.jar -compact -generateJsonSchema [xsd schema] -d [output jsonix dir] -p [Json Schema object]
     * @param args Input arguments
     */
    public static void main(String[] args) {
        //java -jar JSONIX/jsonix-schema-compiler-full-2.3.9.jar -compact -generateJsonSchema test\Note.xsd -d test\jsonixout -p Note
        String inputXsdSchema = args[0];
        String outputDirectory = args[1];
        String jsonSchemaObject = args[2];

        try {
            JsonixRunner jsonixRun;
            jsonixRun = new JsonixRunner(inputXsdSchema, outputDirectory, jsonSchemaObject);
            jsonixRun.execute();

            String jsonInputSchemaFile = jsonixRun.getJsonSchema();
            String jsonOutputSchemaFile = Paths.get(jsonInputSchemaFile).getParent() + File.separator + jsonSchemaObject + ".schema.json";

            anyOf = "\t\"allOf\": [\n" +
                    "        {\n" +
                    "            \"type\": \"object\",\n" +
                    "            \"required\": [\""+ jsonSchemaObject + "\"], \n" +
                    "            \"properties\": {\n" +
                    "                \""+ jsonSchemaObject +"\": {\"$ref\": \"#/definitions/" + jsonSchemaObject + "\"}\n" +
                    "            }\n" +
                    "        } \n" +
                    "    ]\n" +
                    "}";

            System.out.println("Updating " + jsonInputSchemaFile + " for " + jsonSchemaObject);
            List<String> replacedContent = handleFile(jsonInputSchemaFile);
            Files.write(Paths.get(jsonOutputSchemaFile), replacedContent);
            System.out.println("Generated " + jsonOutputSchemaFile);

            jsonixRun.cleanUp();

        } catch (Exception e) {
            System.out.println("An exception occured while running UpdateJsonSchema: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Handle file method that replaces the jsonix specific definitions
     * @param inputFile full path to the jsonix input file
     * @return List of replaced lines
     */
    private static List<String>  handleFile(String inputFile) throws IOException {
        List<String> replaced = new ArrayList<>();
        try (FileInputStream inputStream = new FileInputStream(inputFile);
             Scanner sc = new Scanner(inputStream)) {
            while (sc.hasNextLine()) {
                String line = sc.nextLine();
                //add default schema
                Pattern p = Pattern.compile(startPattern);
                Matcher m = p.matcher(line);
                if (m.matches()) {
                    //System.out.println("Adding entry for default schema");
                    replaced.add(defaultSchema);
                    continue;
                }

                p = Pattern.compile(titlePattern);
                m = p.matcher(line);
                if (m.matches()) {
                    System.out.println("found uppercase title " + m.group(1) + m.group(2) + m.group(3));
                    replaced.add(m.group(1) + m.group(2).toLowerCase() + m.group(3));
                    continue;
                }

                p = Pattern.compile(fieldPattern);
                m = p.matcher(line);
                if (m.matches()) {
                    System.out.println("found uppercase field " + m.group(1) + m.group(2) + m.group(3));
                    replaced.add(m.group(1) + m.group(2).toLowerCase() + m.group(3));
                    continue;
                }

                p = Pattern.compile(refPattern1);
                m = p.matcher(line);
                if (m.matches()) {
                    System.out.println("found uppercase ref " + m.group(1) + m.group(2) + m.group(3));
                    String subLine = m.group(1) + m.group(2).toLowerCase() + m.group(3);

                    p = Pattern.compile(refPattern2);
                    m = p.matcher(subLine);
                    if (m.matches()) {
                        System.out.println("found uppercase ref.ref " + m.group(1) + m.group(2) + m.group(3));
                        subLine = m.group(1) + m.group(2).toLowerCase() + m.group(3);
                    }

                    replaced.add(subLine);
                    continue;
                }



                //replace refs
                p = Pattern.compile(jsonixSchemaPattern);
                m = p.matcher(line);
                if (m.matches()) {
                    String spaces = m.group(1);
                    String type = m.group(2);
                    //System.out.println("Found entry for jsonix def: " + type);
                    String newLine;
                    switch (type) {
                        case "string" :
                        case "ID" : //very typical one that was not translated by jsonix due to it being a nested type
                            newLine = spaces + "\"type\": \"string\"";
                            //System.out.println("   Replacing with json string");
                            break;
                        case "decimal" :
                            newLine = spaces + "\"type\": \"number\"";
                            //System.out.println("   Replacing with json number");
                            break;
                        case "int":
                        case "integer" :
                            newLine = spaces + "\"type\": \"integer\"";
                            //System.out.println("   Replacing with json integer");
                            break;
                        case "dateTime" :
                            newLine = spaces + "\"type\": \"string\"," + "\n" + spaces + "\"format\": \"date-time\"";
                            //System.out.println("   Replacing with json string and format date-time");
                            break;
//                        case "date" : //2022-10-11    YYYY-MM-DD
//                            newLine = spaces + "\"type\": \"string\"," + "\n" + spaces + "\"pattern\": \"^\\d{4}-\\d{2}-\\d{2}$\"";
//                            //System.out.println("   Replacing with json string and format date-time");
//                            break;
                        case "boolean" :
                            newLine = spaces + "\"type\": \"boolean\"";
                            //System.out.println("   Replacing with json boolean");
                            break;
                        default :
                            newLine = spaces + "\"type\": \"YOU SHALL NOT PASS!!!\"";
                            //System.out.println("   >>>>> Did not find a match for type");
                            break;
                    }
                    replaced.add(newLine);
                    continue;
                }

                //replace anyOf
                p = Pattern.compile("\\s{4}\"anyOf\".*");
                m = p.matcher(line);
                if (m.matches()) {
                    //System.out.println("found entry for anyOf");
                    replaced.add(anyOf);
                    break;
                }
                replaced.add(line);
            }
            if (sc.ioException() != null) {
                throw sc.ioException();
            }
        }
        return replaced;
    }
}
